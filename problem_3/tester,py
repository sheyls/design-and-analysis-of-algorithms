import networkx as nx
from aprox_sol import grasp_bipartization
import random
import networkx as nx

def test_bipartization():
    # Grafo completo con n nodos
    n = 10
    graph = nx.complete_graph(n)
    k = n**2//4
    iterations = 10
    #print(grasp_bipartization(graph, k, iterations))
    count_efect(graph, k, iterations)

    # Grafo bipartito con n nodos, m aristas y probabilidad p
    n = 10
    m = 20
    p = 0.5
    graph = nx.bipartite.random_graph(n, m, p)
    k = m
    iterations = 10
    count_efect(graph, k, iterations)

   # print(grasp_bipartization(graph, k, iterations))


    # Grafo aleatorio con n nodos y probabilidad p
    n = 10
    p = 0.5
    graph = nx.erdos_renyi_graph(n, p)
    k = random.randint(1, graph.number_of_edges())
    iterations = 10
    #print(grasp_bipartization(graph, k, iterations))
    count_efect(graph, k, iterations)



    # Grafo en forma de estrella con n nodos
    n = 10
    graph = nx.star_graph(n-1)
    k = n-1
    iterations = 10
    count_efect(graph, k, iterations)

    #print(grasp_bipartization(graph, k, iterations))


    # Grafo en forma de ciclo con n nodos
    n = 10
    graph = nx.cycle_graph(n)
    k = n//2
    iterations = 10
    print(grasp_bipartization(graph, k, iterations))
    count_efect(graph, k, iterations)



def count_efect(G, k, i):
    true = 0
    good = 0

    for _ in range(30):
        for _ in range(30):
            if grasp_bipartization(G, k, i):
                true += 1

        if true > 15:
            good += 1

    if good > 15:
        print(True, good)
    else:
        print(False, 30-good)


test_bipartization()